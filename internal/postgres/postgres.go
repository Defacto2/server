// Package postgres connects to and interacts with a PostgreSQL database server.
// The functions are specific to the Postgres platform rather than more generic or
// interchangeable SQL statements.
//
// The postgres/models directory is generated by SQLBoiler and should not be modified.
package postgres

import (
	"database/sql"
	"errors"
	"fmt"
	"log/slog"
	"net/url"

	"github.com/Defacto2/server/internal/panics"
	"github.com/caarlos0/env/v11"
	_ "github.com/jackc/pgx/v5/stdlib" // Use a lowlevel PostgreSQL driver.
)

var ErrEnvValue = errors.New("environment variable probably contains an invalid value")

const (
	// DefaultURL is an example PostgreSQL connection string, it must not be used in production.
	DefaultURL = "postgres://root:example@localhost:5432/defacto2_ps" //nolint: gosec
	// DriverName of the database.
	DriverName = "pgx"
	// Protocol of the database driver.
	Protocol = "postgres"
)

// Connections returns the number of active connections and the maximum allowed connections.
func Connections(db *sql.DB) (int64, int64, error) {
	const msg = "postgres"
	if db == nil {
		return 0, 0, fmt.Errorf("%s: %w", msg, panics.ErrNoDB)
	}
	rows, err := db.Query("SELECT 'dataname' FROM pg_stat_activity WHERE datname='defacto2_ps';")
	if err != nil {
		return 0, 0, fmt.Errorf("%s query: %w", msg, err)
	}
	if err := rows.Err(); err != nil {
		return 0, 0, fmt.Errorf("%s rows: %w", msg, err)
	}
	defer func() {
		_ = rows.Close()
	}()
	count := int64(0)
	for rows.Next() {
		count++
	}
	maxConn, err := db.Query("SHOW max_connections;")
	if err != nil {
		return 0, 0, fmt.Errorf("%s query: %w", msg, err)
	}
	if err := maxConn.Err(); err != nil {
		return 0, 0, fmt.Errorf("%s rows: %w", msg, err)
	}
	defer func() {
		_ = maxConn.Close()
	}()
	var maxConnections int64
	for maxConn.Next() {
		if err := maxConn.Scan(&maxConnections); err != nil {
			return 0, 0, fmt.Errorf("%s scan: %w", msg, err)
		}
	}
	return count, maxConnections, nil
}

// Open a new connection to the PostgreSQL database.
// Only one connection is needed for the entire application as it is thread-safe
// and can be used repeatedly.
//
// The connection should be closed after the application exits.
func Open() (*sql.DB, error) {
	const msg = "postgres open connection"
	dataSource, err := New()
	if err != nil {
		return nil, fmt.Errorf("%s: %w", msg, err)
	}
	conn, err := sql.Open(DriverName, dataSource.URL)
	if err != nil {
		return nil, fmt.Errorf("%s new: %w", msg, err)
	}
	return conn, nil
}

// New initializes the connection with default values or values from the environment.
func New() (Connection, error) {
	const msg = "postgres new connection"
	c := Connection{
		URL: DefaultURL,
	}
	if err := env.Parse(&c); err != nil {
		return Connection{}, fmt.Errorf("%s default url: %w: %w", msg, ErrEnvValue, err)
	}
	return c, nil
}

// Connection details of the PostgreSQL database connection.
type Connection struct {
	URL string `env:"D2_DATABASE_URL"` // removing this value will cause the default to be used after a single use
}

// Validate the connection URL and print any issues to the logger.
func (c Connection) Validate(logger *slog.Logger) error {
	const msg = "postgres connection validation"
	if logger == nil {
		return fmt.Errorf("%s: %w", msg, panics.ErrNoSlog)
	}
	const key = "issue"
	if c.URL == "" {
		logger.Warn(msg, slog.String(key, "The database connection host name is empty"))
	}
	u, err := url.Parse(c.URL)
	if err != nil {
		logger.Warn(msg,
			slog.String(key, "The database connection URL is invalid"),
			slog.Any("error", err))
		return nil
	}
	if u == nil {
		logger.Warn(msg, slog.String(key, "The database connection URL is nil"))
		return nil
	}
	if u.Scheme != Protocol {
		logger.Warn(msg,
			slog.String(key, "The database connection scheme is invalid"),
			slog.String("requirement", Protocol),
			slog.String("scheme in use", u.Scheme))
	}
	return nil
}
