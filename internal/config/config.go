// Package config manages the environment variable configurations.
package config

import (
	"fmt"
	"log/slog"
	"reflect"
	"slices"
	"strings"

	"github.com/Defacto2/helper"
	"github.com/Defacto2/server/internal/panics"
)

const (
	ConfigDir         = "defacto2-app" // ConfigDir is the subdirectory for the home user ".config".
	MinimumFiles      = 40000          // MinimumFiles is the minimum number of unique filenames expected in an asset subdirectory.
	SessionHours      = 3              // SessionHours is the default number of hours for the session cookie to remain active.
	StdHTTP      Port = 80             // StdHTTP is the standard port used for a legacy unencrypted HTTP connection.
	StdHTTPS     Port = 443            // StdHTTPS is the standard port used for a HTTP web connection.
	StdCustom         = 1323           // StdCustom is the default port number used by this application for an unencrypted HTTP connection.
)

const (
	hide = "xxxxx" // hide is the placeholder text used to replace sensitive information
)

// Config options for the Defacto2 server using the [caarlos0/env] package.
//
// [caarlos0/env]:https://github.com/caarlos0/env
type Config struct { //nolint:recvcheck
	AbsLog         Abslog     `env:"D2_DIR_LOG" help:"The absolute directory path will store all logs generated by this application"`
	AbsDownload    Absdown    `env:"D2_DIR_DOWNLOAD" help:"The directory path that holds the UUID named files that are served as artifact downloads"`
	AbsPreview     Absprev    `env:"D2_DIR_PREVIEW" help:"The directory path that holds the UUID named image files that are served as previews of the artifact"`
	AbsThumbnail   Absthumb   `env:"D2_DIR_THUMBNAIL" help:"The directory path that holds the UUID named squared image files that are served as artifact thumbnails"`
	AbsExtra       Absextra   `env:"D2_DIR_EXTRA" help:"The directory path that holds extra assets of the UUID named files that are generated by the application"`
	AbsOrphaned    Absorphan  `env:"D2_DIR_ORPHANED" help:"The directory path that holds the UUID named files that are not linked to any database records"`
	DatabaseURL    Connection `env:"D2_DATABASE_URL" help:"Provide the URL of the database to which to connect"`
	SessionKey     Sessionkey `env:"D2_SESSION_KEY,unset" help:"Use a fixed session key for the cookie store, which can be left blank to generate a random key"`
	GoogleClientID Googleauth `env:"D2_GOOGLE_CLIENT_ID,unset" help:"The Google OAuth2 client ID"`
	GoogleIDs      Googleids  `env:"D2_GOOGLE_IDS,unset" help:"Create a comma-separated list of Google account IDs to permit access to the editor mode"`
	MatchHost      Matchhost  `env:"D2_MATCH_HOST" help:"Limits connections to the specific host or domain name; leave blank to permit connections from anywhere"`
	TLSCert        Abstlscrt  `env:"D2_TLS_CERT" help:"An absolute file path to the TLS certificate, or leave blank to use a self-signed, localhost certificate"`
	TLSKey         Abstlskey  `env:"D2_TLS_KEY" help:"An absolute file path to the TLS key, or leave blank to use a self-signed, localhost key"`
	GoogleAccounts OAuth2s    // GoogleAccounts is the data store for the GoogleIDs.
	HTTPPort       PortHTTP   `env:"D2_HTTP_PORT" help:"The port number to be used by the unencrypted HTTP web server"`
	MaxProcs       Threads    `env:"D2_MAX_PROCS" help:"Limit the number of operating system threads the program can use"`
	SessionMaxAge  Hours      `env:"D2_SESSION_MAX_AGE" help:"List the maximum number of hours for the session cookie to remain active before expiring and requiring a new login"`
	TLSPort        PortTLS    `env:"D2_TLS_PORT" help:"The port number to be used by the encrypted, HTTPS web server"`
	Quiet          Toggle     `env:"D2_QUIET" help:"Suppress most startup output to the terminal, intended for use with systemd or other process managers"`
	Compression    Toggle     `env:"D2_COMPRESSION" help:"Enable gzip compression of the HTTP/HTTPS responses; you may turn this off when using a reverse proxy"`
	ProdMode       Toggle     `env:"D2_PROD_MODE" help:"Use the production mode to log errors to files and recover from panics"`
	ReadOnly       Toggle     `env:"D2_READ_ONLY" help:"Use the read-only mode to turn off all POST, PUT, and DELETE requests and any related user interface"`
	NoCrawl        Toggle     `env:"D2_NO_CRAWL" help:"Tell search engines to not crawl any of website pages or assets"`
	LogAll         Toggle     `env:"D2_LOG_ALL" help:"Log all HTTP and HTTPS client requests including those with 200 OK responses"`
}

// Format returns a human readable description of the named configuration identifier.
func Format(name string) string {
	m := map[string]string{
		"AbsDownload":    "Downloads, directory path",
		AbsPreview:       "Previews, directory path",
		AbsThumbnail:     "Thumbnails, directory path",
		"AbsLog":         "Logs, directory path",
		"AbsExtra":       "Extras, directory path",
		"AbsOrphaned":    "Orphaned, directory path",
		"Compression":    "Gzip compression",
		"DatabaseURL":    "Database connection, URL",
		"GoogleClientID": "Google OAuth2 client ID",
		"GoogleIDs":      "Google IDs for sign-in",
		"LogAll":         "Log all HTTP requests",
		"MaxProcs":       "Maximum CPU processes",
		"MatchHost":      "Match hostname, domain or IP address",
		"NoCrawl":        "Disallow search engine crawling",
		"ProdMode":       "Production mode",
		"Quiet":          "Quiet mode",
		"ReadOnly":       "Read-only mode",
		"SessionKey":     "Session encryption key",
		"SessionMaxAge":  "Maximum age of a session for the web administration",
		"TLSCert":        "TLS certificate, file path",
		"TLSHost":        "TLS hostname",
		"TLSKey":         "TLS key, file path",
	}
	if desc, found := m[name]; found {
		return desc
	}
	return helper.SplitAsSpaces(name)
}

// Info returns the results of the optional Info method for the named configuration identifier.
// The value needs to be the interface results of the field by name reflection.
func Info(name string, value any) string {
	s := Format(name)
	v := reflect.ValueOf(value)
	switch name {
	case "GoogleAccounts", "SessionMaxAge":
		return fmt.Sprintf("%s, %s", s, v)
	case "MaxProcs":
		return fmt.Sprintf("%s %s", s, v)
	}
	switch v.Kind() {
	case reflect.Bool:
		return fmt.Sprintf("%s is %s", s, info(v))
	default:
		return s
	}
}

func info(val reflect.Value) string {
	if val.Bool() {
		return "on"
	}
	return "off"
}

func skip(name string) bool {
	name = strings.ToLower(name)
	switch name {
	case "googleaccounts":
		return true
	default:
		return false
	}
}

// Print the configuration using the sl logger.
// Configurations names are obtained from the Config struct and are parsed
// with custom help and issue reports.
func (c Config) Print(sl *slog.Logger) {
	const msg = "config print"
	if sl == nil {
		panic(fmt.Errorf("%s: %w", msg, panics.ErrNoSlog))
	}
	fields := reflect.VisibleFields(reflect.TypeOf(c))
	names := c.Names()
	for i, name := range slices.All(names) {
		if skip(name) {
			continue
		}
		tag := fields[i].Tag.Get("env") // tag obtains the `env:` value from the struct
		vof := reflect.ValueOf(c)
		val := vof.FieldByName(name).Interface()
		inf := Info(name, val)
		issue := vof.FieldByName(name).MethodByName("Issue")
		if issue.IsValid() {
			issuer := issue.Call([]reflect.Value{})
			if len(issuer) != 0 && issuer[0].String() != "" {
				sl.Error(inf, slog.Any(tag, val), slog.String("issue", issuer[0].String()))
				continue
			}
		}
		// help includes the result of the Help() method, when it exists for the named configuration
		help := vof.FieldByName(name).MethodByName("Help")
		if name == "GoogleIDs" && help.IsValid() {
			googleIDs(vof, sl, tag)
			continue
		}
		if help.IsValid() {
			h := help.Call([]reflect.Value{})
			if len(h) > 0 && h[0].String() != "" {
				helper := h[0].String()
				sl.Info(inf, slog.Any(tag, val), slog.String("help", helper))
				continue
			}
		}
		sl.Info(inf, slog.Any(tag, val))
	}
}

func googleIDs(vof reflect.Value, sl *slog.Logger, tag string) {
	const n = "GoogleAccounts"
	swap := vof.FieldByName(n).MethodByName("Help")
	if !swap.IsValid() {
		return
	}
	h := swap.Call([]reflect.Value{})
	if len(h) == 0 || h[0].String() == "" {
		return
	}
	helper := h[0].String()
	swap = vof.FieldByName(n).MethodByName("String")
	v := swap.Call([]reflect.Value{})
	if len(v) == 0 {
		return
	}
	vals := v[0]
	inf := Info(n, vals)
	sl.Info(inf, slog.Any(tag, hide), slog.String("help", helper))
}

// Names returns a list of the field names in the Config struct.
func (c Config) Names() []string {
	t := reflect.TypeOf(c)
	fieldNames := make([]string, t.NumField())
	for i := range t.NumField() {
		fieldNames[i] = t.Field(i).Name
	}
	return fieldNames
}

// Addresses returns a list of urls that the server is accessible from.
func (c Config) Addresses(sl *slog.Logger) error {
	const msg = "config addresses"
	if sl == nil {
		return fmt.Errorf("%s: %w", msg, panics.ErrNoSlog)
	}
	if err := c.addresses(sl, true); err != nil {
		return fmt.Errorf("%s: %w", msg, err)
	}
	return nil
}

// addresses prints a list of urls that the server is accessible from.
func (c Config) addresses(sl *slog.Logger, help bool) error {
	values := reflect.ValueOf(c)
	if help {
		s := "Depending on the firewall and operating system setup, " +
			"the defacto2 web server maybe accessible from these links"
		sl.Info("urls", slog.String("about", s))
	}
	hosts, err := helper.LocalHosts()
	if err != nil {
		return fmt.Errorf("the server cannot get the local host names: %w", err)
	}
	port := values.FieldByName("HTTPPort").Uint()
	tls := values.FieldByName("TLSPort").Uint()
	if port == 0 && tls == 0 {
		return ErrNoPort
	}
	const disable, text, secure = 0, 80, 443
	const li = "urls"
	for host := range slices.Values(hosts) {
		if c.MatchHost != "" && host != c.MatchHost.String() {
			continue
		}
		s := "" //nolint:wastedassign
		switch port {
		case text:
			s = "http://" + host
		case disable:
			continue
		default:
			s = fmt.Sprintf("http://%s:%d", host, port)
		}
		sl.Info(li, slog.String("link", s))
		switch tls {
		case secure:
			s = "https://" + host
		case disable:
			continue
		default:
			s = fmt.Sprintf("https://%s:%d", host, tls)
		}
		sl.Info(li, slog.String("link", s))
	}
	if c.MatchHost != "" {
		return nil
	}
	ips, err := helper.LocalIPs()
	if err != nil {
		return fmt.Errorf("the server cannot get the local IP addresses: %w", err)
	}
	for ip := range slices.Values(ips) {
		if port == 0 {
			break
		}
		s := fmt.Sprintf("http://%s:%d", ip, port)
		sl.Info(li, slog.String("link", s))
	}
	return nil
}

// StaticThumb returns the path to the thumbnail directory.
func StaticThumb() string {
	return "/public/image/thumb"
}

// StaticOriginal returns the path to the image directory.
func StaticOriginal() string {
	return "/public/image/original"
}
