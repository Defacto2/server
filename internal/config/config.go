// Package config manages the environment variable configurations.
package config

import (
	"crypto/sha512"
	"errors"
	"fmt"
	"log/slog"
	"net/url"
	"os"
	"reflect"
	"slices"
	"sort"
	"strings"
	"text/tabwriter"

	"github.com/Defacto2/helper"
)

const (
	ConfigDir    = "defacto2-app" // ConfigDir is the subdirectory for the home user ".config".
	HTTPPort     = 1323           // HTTPPort is the default port number for the unencrypted HTTP server.
	SessionHours = 3              // SessionHours is the default number of hours for the session cookie to remain active.
	MinimumFiles = 40000          // MinimumFiles is the minimum number of unique filenames expected in an asset subdirectory.
	Down         = "AbsDownload"  // AbsDownload means the absolute download asset directory.
	Logger       = "AbsLog"       // AbsLog means the absolute log directory.
	Prev         = "AbsPreview"   // AbsPreview means the absolute preview assets directory.
	Thumb        = "AbsThumbnail" // AbsThumbnail means the absolute thumbnail assets directory.
)

const (
	minwidth = 2
	tabwidth = 4
	padding  = 2
	padchar  = ' '
	flags    = 0
	hide     = "xxxxx"
	h1       = "Configuration"
	h2       = "Value"
	h3       = "Environment variable"
	line     = "â”€"
)

var (
	ErrNoPort  = errors.New("the server cannot start without a http or a tls port")
	ErrPointer = errors.New("pointer is nil")
	ErrVer     = errors.New("postgresql version request failed")
	// ErrDirNil  = errors.New("directory does not exist")
	ErrDirNot  = errors.New("path points to a file")
	ErrFileNot = errors.New("path points to a directory")
)

// Configuration is a struct that holds the configuration options.
type Configuration struct {
	Title       string // Title is the name of the configuration option.
	Variable    string // Variable is the environment variable name.
	Value       string // Value of the configuration option that is safe to print.
	Description string // Description is the help text for the configuration option.
}

// Config options for the Defacto2 server using the [caarlos0/env] package.
//
// [caarlos0/env]:https://github.com/caarlos0/env
type Config struct { //nolint:recvcheck
	AbsLog         Abslog     `env:"D2_DIR_LOG" help:"The absolute directory path will store all logs generated by this application"`
	AbsDownload    Absdown    `env:"D2_DIR_DOWNLOAD" help:"The directory path that holds the UUID named files that are served as artifact downloads"`
	AbsPreview     Absprev    `env:"D2_DIR_PREVIEW" help:"The directory path that holds the UUID named image files that are served as previews of the artifact"`
	AbsThumbnail   Absthumb   `env:"D2_DIR_THUMBNAIL" help:"The directory path that holds the UUID named squared image files that are served as artifact thumbnails"`
	AbsExtra       Absextra   `env:"D2_DIR_EXTRA" help:"The directory path that holds extra assets of the UUID named files that are generated by the application"`
	AbsOrphaned    Absorphan  `env:"D2_DIR_ORPHANED" help:"The directory path that holds the UUID named files that are not linked to any database records"`
	DatabaseURL    Connection `env:"D2_DATABASE_URL" help:"Provide the URL of the database to which to connect"`
	SessionKey     Sessionkey `env:"D2_SESSION_KEY,unset" help:"Use a fixed session key for the cookie store, which can be left blank to generate a random key"`
	GoogleClientID Googleauth `env:"D2_GOOGLE_CLIENT_ID,unset" help:"The Google OAuth2 client ID"`
	GoogleIDs      Googleids  `env:"D2_GOOGLE_IDS,unset" help:"Create a comma-separated list of Google account IDs to permit access to the editor mode"`
	MatchHost      Matchhost  `env:"D2_MATCH_HOST" help:"Limits connections to the specific host or domain name; leave blank to permit connections from anywhere"`
	TLSCert        Abstlscrt  `env:"D2_TLS_CERT" help:"An absolute file path to the TLS certificate, or leave blank to use a self-signed, localhost certificate"`
	TLSKey         Abstlskey  `env:"D2_TLS_KEY" help:"An absolute file path to the TLS key, or leave blank to use a self-signed, localhost key"`
	GoogleAccounts OAuth2s    //[][48]byte
	HTTPPort       PortHttp   `env:"D2_HTTP_PORT" help:"The port number to be used by the unencrypted HTTP web server"`
	MaxProcs       Threads    `env:"D2_MAX_PROCS" help:"Limit the number of operating system threads the program can use"`
	SessionMaxAge  Hours      `env:"D2_SESSION_MAX_AGE" help:"List the maximum number of hours for the session cookie to remain active before expiring and requiring a new login"`
	TLSPort        PortTls    `env:"D2_TLS_PORT" help:"The port number to be used by the encrypted, HTTPS web server"`
	Quiet          Toggle     `env:"D2_QUIET" help:"Suppress most startup output to the terminal, intended for use with systemd or other process managers"`
	Compression    Toggle     `env:"D2_COMPRESSION" help:"Enable gzip compression of the HTTP/HTTPS responses; you may turn this off when using a reverse proxy"`
	ProdMode       Toggle     `env:"D2_PROD_MODE" help:"Use the production mode to log errors to files and recover from panics"`
	ReadOnly       Toggle     `env:"D2_READ_ONLY" help:"Use the read-only mode to turn off all POST, PUT, and DELETE requests and any related user interface"`
	NoCrawl        Toggle     `env:"D2_NO_CRAWL" help:"Tell search engines to not crawl any of website pages or assets"`
	LogAll         Toggle     `env:"D2_LOG_ALL" help:"Log all HTTP and HTTPS client requests including those with 200 OK responses"`
}

type Abstlskey File

func (a Abstlskey) Help() string {
	if a == "" {
		return "No TLS key is in use"
	}
	return ""
}

func (a Abstlskey) Issue() string {
	return Directory(a).Issue()
}

func (a Abstlskey) LogValue() slog.Value {
	return Directory(a).LogValue()
}

func (a Abstlskey) String() string {
	return Directory(a).String()
}

type Abstlscrt File

func (a Abstlscrt) Help() string {
	if a == "" {
		return "No TLS certificate is in use"
	}
	return ""
}

func (a Abstlscrt) Issue() string {
	return Directory(a).Issue()
}

func (a Abstlscrt) LogValue() slog.Value {
	return Directory(a).LogValue()
}

func (a Abstlscrt) String() string {
	return Directory(a).String()
}

type File string

func (f File) LogValue() slog.Value {
	if f == "" {
		return slog.StringValue("")
	}
	return slog.StringValue(string(f))
}

func (f File) Okay() error {
	st, err := os.Stat(string(f))
	if err != nil {
		return err
	}
	if !st.IsDir() {
		return nil
	}
	return ErrFileNot
}

func (f File) String() string {
	return string(f)
}

func (f File) Issue() string {
	if f == "" {
		return ""
	}
	err := f.Okay()
	if errors.Is(err, os.ErrNotExist) {
		return "File does not exist"
	}
	if errors.Is(err, ErrDirNot) {
		return "File path points to a file and cannot be used"
	}
	return ""
}

// OAuth2s is a slice of Google OAuth2 accounts that are allowed to login.
// Each account is a 48 byte slice of bytes that represents the SHA-384 hash of the unique Google ID.
type OAuth2s [][48]byte

func (o OAuth2s) LogValue() slog.Value {
	return slog.Value{}
}

func (o OAuth2s) Values() [][48]byte {
	return o
}

func (o OAuth2s) String() string {
	cnt := len(o)
	switch cnt {
	case 0:
		return ""
	case 1:
		return "one sign-in account"
	default:
		return "multiple sign-in accounts"

	}
}

func (o OAuth2s) Help() string {
	return Googles(o)
}

// Googles TODO:
func Googles(ids [][48]byte) string {
	const none = "No accounts configured for the web administration"
	if ids == nil {
		return none
	}
	cnt := len(ids)
	switch cnt {
	case 0:
		return none
	case 1:
		return "1 Google account in use for the web administration"
	default:
		return fmt.Sprintf("%d Google accounts in use for the web administration", cnt)
	}
}

type Googleauth string

func (g Googleauth) LogValue() slog.Value {
	if string(g) == "" {
		return slog.StringValue("Empty")
	}
	return slog.StringValue(hide)
}

func (g Googleauth) Help() string {
	if string(g) == "" {
		return "No accounts for web administration"
	}
	return ""
}

func (g Googleauth) String() string {
	return string(g)
}

type Googleids string

func (g Googleids) LogValue() slog.Value {
	if g == "" {
		return slog.StringValue("")
	}
	return slog.StringValue(hide)
}

func (g Googleids) Help() string {
	const none = "No accounts configured for the web administration"
	if g == "" {
		return none
	}
	cnt := len(strings.Split(g.String(), ","))
	switch cnt {
	case 0:
		return none
	case 1:
		return "1 Google account in use for sign-in"
	default:
		return fmt.Sprintf("%d Google accounts in use for sign-ins", cnt)
	}
}

func (g Googleids) String() string {
	return string(g)
}

type Directory string

func (d Directory) LogValue() slog.Value {
	if d == "" {
		return slog.StringValue("")
	}
	return slog.StringValue(string(d))
}

func (d Directory) Okay() error {
	st, err := os.Stat(string(d))
	if err != nil {
		return err
	}
	if st.IsDir() {
		return nil
	}
	return ErrDirNot
}

func (d Directory) String() string {
	return string(d)
}

func (d Directory) Issue() string {
	if d == "" {
		return ""
	}
	err := d.Okay()
	if errors.Is(err, os.ErrNotExist) {
		return "Directory does not exist"
	}
	if errors.Is(err, ErrDirNot) {
		return "Directory path points to a file and cannot be used"
	}
	return ""
}

type Abslog Directory

func (a Abslog) Help() string {
	if a == "" {
		return "No logs will be saved"
	}
	return ""
}

func (a Abslog) Issue() string {
	return Directory(a).Issue()
}

func (a Abslog) LogValue() slog.Value {
	return Directory(a).LogValue()
}

func (a Abslog) String() string {
	return Directory(a).String()
}

type Absdown Directory

func (a Absdown) Help() string {
	if a == "" {
		return "No downloads will be served"
	}
	return ""
}

func (a Absdown) Issue() string {
	return Directory(a).Issue()
}

func (a Absdown) LogValue() slog.Value {
	return Directory(a).LogValue()
}

func (a Absdown) String() string {
	return Directory(a).String()
}

type Absprev Directory

func (a Absprev) Help() string {
	if a == "" {
		return "No preview images will be shown"
	}
	return ""
}

func (a Absprev) Issue() string {
	return Directory(a).Issue()
}

func (a Absprev) LogValue() slog.Value {
	return Directory(a).LogValue()
}

func (a Absprev) String() string {
	return Directory(a).String()
}

type Absthumb Directory

func (a Absthumb) Help() string {
	if a == "" {
		return "No thumbnails will be shown"
	}
	return ""
}

func (a Absthumb) Issue() string {
	return Directory(a).Issue()
}

func (a Absthumb) LogValue() slog.Value {
	return Directory(a).LogValue()
}

func (a Absthumb) String() string {
	return Directory(a).String()
}

type Absextra Directory

func (a Absextra) Help() string {
	if a == "" {
		return "No textfiles will be shown"
	}
	return ""
}

func (a Absextra) Issue() string {
	return Directory(a).Issue()
}

func (a Absextra) LogValue() slog.Value {
	return Directory(a).LogValue()
}

func (a Absextra) String() string {
	return Directory(a).String()
}

type Absorphan Directory

func (a Absorphan) Help() string {
	if a == "" {
		return "Artifact backups are not possible"
	}
	return ""
}

func (a Absorphan) Issue() string {
	return Directory(a).Issue()
}

func (a Absorphan) LogValue() slog.Value {
	return Directory(a).LogValue()
}

func (a Absorphan) String() string {
	return Directory(a).String()
}

type PortHttp uint

func (p PortHttp) LogValue() slog.Value {
	return slog.IntValue(int(p))
}

func (p PortHttp) Help() string {
	return protoPort(uint(p), 80, "http")
}

func (p PortHttp) Value() uint {
	return uint(p)
}

func (p PortHttp) Okay() error {
	return Validate(uint(p))
}

type PortTls uint

func (p PortTls) LogValue() slog.Value {
	return slog.IntValue(int(p))
}

func (p PortTls) Help() string {
	return protoPort(uint(p), 443, "https")
}

func (p PortTls) Value() uint {
	return uint(p)
}

func (p PortTls) Okay() error {
	return Validate(uint(p))
}

func protoPort(p, stdport uint, proto string) string {
	if p == 0 {
		return "The web server is not using " + strings.ToUpper(proto)
	}
	s := "The web server is using " + strings.ToUpper(proto) +
		", example: " + strings.ToLower(proto) + "://localhost"
	if p != stdport {
		s = fmt.Sprintf("The web server is using %s, example: %s://localhost:%d",
			strings.ToUpper(proto), strings.ToLower(proto), p)
	}
	return s
}

type Matchhost string

func (m Matchhost) LogValue() slog.Value {
	if m == "" {
		return slog.StringValue("")
	}
	return slog.StringValue(string(m))
}

func (m Matchhost) Help() string {
	if m == "" {
		return "No host address restrictions."
	}
	return ""
}

func (m Matchhost) String() string {
	return string(m)
}

type Sessionkey string

func (s Sessionkey) LogValue() slog.Value {
	if s == "" {
		return slog.StringValue("")
	}
	return slog.StringValue(hide)
}

func (s Sessionkey) Help() string {
	if s == "" {
		return "A random key will be generated during the server start."
	}
	return ""
}

func (s Sessionkey) String() string {
	return string(s)
}

type Connection string

func (c Connection) LogValue() slog.Value {
	rawURL := string(c)
	u, err := url.Parse(rawURL)
	if err != nil {
		return slog.StringValue(rawURL)
	}
	_, exists := u.User.Password()
	if !exists {
		return slog.StringValue(rawURL)
	}
	u.User = url.UserPassword(u.User.Username(), hide)
	return slog.StringValue(u.String())
}

type Threads uint

func (t Threads) LogValue() slog.Value {
	return slog.Uint64Value(uint64(t))
}

func (t Threads) String() string {
	if t == 0 {
		return "are not set"
	}
	return fmt.Sprintf("%d CPU threads", t)
}

func (t Threads) Help() string {
	if t == 0 {
		return "The application will use all available CPU threads."
	}
	return "The application will limit usage of the CPU."
}

// Validate returns an error if the HTTP or TLS port is invalid.
// TODO: move
func Validate(port uint) error {
	const disabled = 0
	if port == disabled {
		return nil
	}
	if port > PortMax {
		return ErrPortMax
	}
	if port <= PortSys {
		return ErrPortSys
	}
	return nil
}

type Toggle bool // Toggle is a boolean value that returns a humanized string

func (t Toggle) LogValue() slog.Value {
	if t {
		return slog.StringValue("TRUE")
	}
	return slog.StringValue("FALSE")
}

func (t Toggle) Bool() bool {
	return bool(t)
}

type Hours int // Hours is a duration value

func (h Hours) LogValue() slog.Value {
	return slog.IntValue(int(h))
}

func (h Hours) String() string {
	if h == 1 {
		return "1 hour"
	}
	return fmt.Sprintf("%d hours", h)
}

func (h Hours) Int() int {
	return int(h)
}

func (c Config) Print(l *slog.Logger) {
	l.Info("The Defacto2 server configuration :")
	fields := reflect.VisibleFields(reflect.TypeOf(c))
	names := c.Names()
	for i, name := range slices.All(names) {
		if skip(name) {
			continue
		}
		// tag obtains the `env:` value from the struct
		tag := fields[i].Tag.Get("env")
		// logval must pass in the interface value for the slog.LogValue filter to work
		vof := reflect.ValueOf(c)
		val := vof.FieldByName(name).Interface()
		inf := Info(name, val)
		// println(">>", inf)
		issue := vof.FieldByName(name).MethodByName("Issue")
		if issue.IsValid() {
			issuer := issue.Call(nil)[0].String()
			l.Error(inf,
				slog.Any(tag, val),
				slog.String("issue", issuer))
			continue
		}
		// help includes the result of the Help() method, when it exists
		help := vof.FieldByName(name).MethodByName("Help")
		helper := ""

		if name == "GoogleIDs" && help.IsValid() {
			const n = "GoogleAccounts"
			swap := vof.FieldByName(n).MethodByName("Help")
			if !swap.IsValid() {
				continue
			}
			helper = swap.Call(nil)[0].String()
			swap = vof.FieldByName(n).MethodByName("String")
			vals := swap.Call(nil)[0]
			inf = Info(n, vals)
			l.Info(inf,
				slog.Any(tag, hide),
				slog.String("help", helper))
			continue
		}

		if help.IsValid() {
			// handle edge cases like googleids using GoogleAccounts data
			helper = help.Call(nil)[0].String()
			l.Info(inf,
				slog.Any(tag, val),
				slog.String("help", helper))
			continue
		}
		l.Info(inf,
			slog.Any(tag, val))
	}
}

func skip(name string) bool {
	name = strings.ToLower(name)
	switch name {
	case "googleaccounts":
		return true
	default:
		return false
	}
}

// Names returns a list of the field names in the Config struct.
func (c Config) Names() []string {
	t := reflect.TypeOf(c)
	fieldNames := make([]string, t.NumField())
	for i := range t.NumField() {
		fieldNames[i] = t.Field(i).Name
	}
	return fieldNames
}

// String returns a string representation of the Config struct.
// The output is formatted as a table with the following columns:
// Environment variable and Value.
func (c Config) String() string {
	b := new(strings.Builder)
	c.fprint(b)
	return b.String()
}

// fprintDirs prints the directory path to the tabwriter or a warning if the path is empty.
// TODO: rm
func fprintDirs(w *tabwriter.Writer, id, name, val string) {
	_, _ = fmt.Fprintf(w, "\t%s\t%s", Format(id), name)
	if val != "" {
		if st, err := os.Stat(val); err != nil && os.IsNotExist(err) {
			_, _ = fmt.Fprintf(w, "\t%s\n\t\t\tProblem: DIRECTORY DOES NOT EXIST\n", val)
			return
		} else if err != nil {
			_, _ = fmt.Fprintf(w, "\t%s\n\t\t\tError: %s\n", val, err)
			return
		} else if !st.IsDir() {
			_, _ = fmt.Fprintf(w, "\t%s\n\t\t\tProblem: PATH POINTS TO A FILE\n", val)
			return
		}
		_, _ = fmt.Fprintf(w, "\t%s\n", val)
		return
	}
	switch id {
	case Down:
		_, _ = fmt.Fprintf(w, "\tEmpty, no downloads will be served\n")
	case Prev:
		_, _ = fmt.Fprintf(w, "\tEmpty, no preview images will be shown\n")
	case Thumb:
		_, _ = fmt.Fprintf(w, "\tEmpty, no thumbnails will be shown\n")
	case Logger:
		_, _ = fmt.Fprintf(w, "\tEmpty, logs print to the terminal (stdout)\n")
	default:
		_, _ = fmt.Fprintln(w)
	}
}

// fprintField2 prints the id, name, value and help text to the tabwriter.
func fprintField2(w *tabwriter.Writer, id, name string, val reflect.Value) {
	if val.Kind() == reflect.Bool {
		_, _ = fmt.Fprintf(w, "\t%s\t%s\t%v\n", Format(id), name, valueBool(val))
		return
	}
	_, _ = fmt.Fprintf(w, "\t%s\t%s\t", Format(id), name)
	switch id {
	case "GoogleClientID":
		_, _ = fmt.Fprintln(w, valueGoogleIDs(val))
	case "MatchHost":
		_, _ = fmt.Fprintln(w, valueMatchHost(val))
	case "SessionKey":
		_, _ = fmt.Fprintln(w, valueSessionKey(val))
	case "SessionMaxAge":
		_, _ = fmt.Fprintln(w, valueHours(val))
	case "DatabaseURL":
		_, _ = fmt.Fprintln(w, valueDatabase(val.String()))
	default:
		if val.String() == "" {
			_, _ = fmt.Fprintln(w, "Empty")
			return
		}
		if val.IsValid() {
			_, _ = fmt.Fprintf(w, "%v\n", val)
		}
	}
}

// Addresses returns a list of urls that the server is accessible from.
func (c Config) Addresses() (string, error) {
	b := new(strings.Builder)
	if err := c.addresses(b, true); err != nil {
		return "", fmt.Errorf("list of server addresses: %w", err)
	}
	return b.String(), nil
}

func addressesHelper(b *strings.Builder) {
	fmt.Fprintf(b, "%s\n",
		"Depending on your firewall, network and certificate setup,")
	fmt.Fprintf(b, "%s\n",
		"this web server could be accessible from the following addresses:")
	fmt.Fprintf(b, "\n")
}

func localIPs(b *strings.Builder, port uint64, pad string) error {
	ips, err := helper.LocalIPs()
	if err != nil {
		return fmt.Errorf("the server cannot get the local IP addresses: %w", err)
	}
	for ip := range slices.Values(ips) {
		if port == 0 {
			break
		}
		fmt.Fprintf(b, "%shttp://%s:%d\n", pad, ip, port)
	}
	return nil
}

// Format returns a human readable description of the named configuration identifier.
func Format(name string) string {
	m := map[string]string{
		Down:             "Downloads, directory path",
		Prev:             "Previews, directory path",
		Thumb:            "Thumbnails, directory path",
		Logger:           "Logs, directory path",
		"AbsExtra":       "Extras, directory path",
		"AbsOrphaned":    "Orphaned, directory path",
		"Compression":    "Gzip compression",
		"DatabaseURL":    "Database connection, URL",
		"GoogleClientID": "Google OAuth2 client ID",
		"GoogleIDs":      "Google IDs for sign-in",
		"LogAll":         "Log all HTTP requests",
		"MaxProcs":       "Maximum CPU processes",
		"MatchHost":      "Match hostname, domain or IP address",
		"NoCrawl":        "Disallow search engine crawling",
		"ProdMode":       "Production mode",
		"Quiet":          "Quiet mode",
		"ReadOnly":       "Read-only mode",
		"SessionKey":     "Session encryption key",
		"SessionMaxAge":  "Maximum age of a session for the web administration",
		"TLSCert":        "TLS certificate, file path",
		"TLSHost":        "TLS hostname",
		"TLSKey":         "TLS key, file path",
	}
	if desc, found := m[name]; found {
		return desc
	}
	return helper.SplitAsSpaces(name)
}

func Info(name string, value any) string {
	s := Format(name)
	v := reflect.ValueOf(value)
	switch name {
	case "GoogleAccounts", "SessionMaxAge":
		return fmt.Sprintf("%s, %s", s, v)
	case "MaxProcs":
		return fmt.Sprintf("%s %s", s, v)
	}
	switch v.Kind() {
	case reflect.Bool:
		return fmt.Sprintf("%s is %s", s, valueBool(v))
	default:
		return s
	}
}

// WARN: temp function?
func Name(val reflect.Value) string {
	return ""
}

// TODO: remove
func valueBool(val reflect.Value) string {
	if val.Bool() {
		return "on"
	}
	return "off"
}

// TODO: remove
func valueGoogleIDs(val reflect.Value) string {
	if val.String() == "" {
		return "Empty, no accounts for web administration"
	}
	return hide
}

// TODO: rm
func valueMatchHost(val reflect.Value) string {
	if val.String() == "" {
		return "Empty, no address restrictions"
	}
	return val.String()
}

// TODO: rm
func valueSessionKey(val reflect.Value) string {
	if val.String() == "" {
		return "Empty, a random key will be generated during the server start"
	}
	return hide
}

// TODO: rm
func valueHours(val reflect.Value) string {
	i := val.Int()
	if i == 1 {
		return "1 hour"
	}
	return fmt.Sprintf("%v hours", i)
}

// valueHTTP prints the HTTP port number to the tabwriter.
// TODO: remove
func valueHTTP(val reflect.Value) string {
	if val.Kind() == reflect.Uint && val.Uint() == 0 {
		return "Unused, the web server will not use HTTP"
	}
	port := val.Uint()
	const common = 80
	if port == common {
		return fmt.Sprintf("%d, the web server will use HTTP, example: http://localhost", port)
	}
	return fmt.Sprintf("%d, the web server will use HTTP, example: http://localhost:%d", port, port)
}

// valueTLS prints the HTTPS port number to the tabwriter.
// TODO: remove
func valueTLS(val reflect.Value) string {
	if val.Kind() == reflect.Uint && val.Uint() == 0 {
		return "Unused, the web server will not use HTTPS"
	}
	port := val.Uint()
	const common = 443
	if port == common {
		return fmt.Sprintf("%d, the web server will use HTTPS, example: https://localhost", port)
	}
	return fmt.Sprintf("%d, the web server will use HTTPS, example: https://localhost:%d", port, port)
}

// valueCert prints the TLS certificate and key locations to the tabwriter.
// TODO: rm
func valueCert(val reflect.Value, tlsport uint) string {
	if tlsport == 0 {
		return "Not in use"
	}
	if val.String() == "" {
		return "Empty, will use a placeholder configuration"
	}
	return val.String()
}

// valueProcs prints the number of CPU cores to the tabwriter.
// TODO: rm
func valueProcs(val reflect.Value) string {
	if val.Kind() == reflect.Uint && val.Uint() == 0 {
		return "Unused, the application will use all available CPU threads"
	}
	return fmt.Sprintf("%d, the application will limit access to CPU threads\n", val.Uint())
}

// valueDatabase replaces the password in the database connection URL with XXXXXs.
// TODO: rm
func valueDatabase(rawURL string) string {
	u, err := url.Parse(rawURL)
	if err != nil {
		return rawURL
	}
	_, exists := u.User.Password()
	if !exists {
		return rawURL
	}
	u.User = url.UserPassword(u.User.Username(), hide)
	return u.String()
}

// TODO: rm
func valueGoogles(ids [][48]byte) string {
	l := len(ids)
	switch l {
	case 0:
		return "Empty, no accounts for web administration"
	case 1:
		return "1 Google account allowed to sign-in"
	default:
		return fmt.Sprintf("%d Google accounts allowed to sign-in", l)
	}
}

// StaticThumb returns the path to the thumbnail directory.
func StaticThumb() string {
	return "/public/image/thumb"
}

// StaticOriginal returns the path to the image directory.
func StaticOriginal() string {
	return "/public/image/original"
}

// UseTLS returns true if the server is configured to use TLS.
func (c Config) UseTLS() bool {
	return c.TLSPort > 0 && c.TLSCert != "" || c.TLSKey != ""
}

// UseHTTP returns true if the server is configured to use HTTP.
func (c Config) UseHTTP() bool {
	return c.HTTPPort > 0
}

// UseTLSLocal returns true if the server is configured to use the local-mode.
func (c Config) UseTLSLocal() bool {
	return c.TLSPort > 0 && c.TLSCert == "" && c.TLSKey == ""
}

// Override the configuration settings fetched from the environment.
func (c *Config) Override() {
	// hash and delete any supplied google ids
	ids := strings.Split(c.GoogleIDs.String(), ",")
	for id := range slices.Values(ids) {
		sum := sha512.Sum384([]byte(id))
		c.GoogleAccounts = append(c.GoogleAccounts, sum)
	}
	c.GoogleIDs = "overwrite placeholder"
	c.GoogleIDs = "" // empty the string

	// set the default HTTP port if both ports are configured to zero
	if c.HTTPPort == 0 && c.TLSPort == 0 {
		c.HTTPPort = HTTPPort
	}
}

// addresses prints a list of urls that the server is accessible from.
func (c Config) addresses(b *strings.Builder, help bool) error {
	pad := strings.Repeat(string(padchar), padding)
	values := reflect.ValueOf(c)
	if help {
		addressesHelper(b)
	}
	hosts, err := helper.LocalHosts()
	if err != nil {
		return fmt.Errorf("the server cannot get the local host names: %w", err)
	}
	port := values.FieldByName("HTTPPort").Uint()
	tls := values.FieldByName("TLSPort").Uint()
	if port == 0 && tls == 0 {
		return ErrNoPort
	}
	const disable, text, secure = 0, 80, 443
	for host := range slices.Values(hosts) {
		if c.MatchHost != "" && host != c.MatchHost.String() {
			continue
		}
		switch port {
		case text:
			fmt.Fprintf(b, "%shttp://%s\n", pad, host)
		case disable:
			continue
		default:
			fmt.Fprintf(b, "%shttp://%s:%d\n", pad, host, port)
		}
		switch tls {
		case secure:
			fmt.Fprintf(b, "%shttps://%s\n", pad, host)
		case disable:
			continue
		default:
			fmt.Fprintf(b, "%shttps://%s:%d\n", pad, host, tls)
		}
	}
	if c.MatchHost == "" {
		return localIPs(b, port, pad)
	}
	return nil
}

// fprint prints a list of active configurations options.
func (c Config) fprint(b *strings.Builder) *strings.Builder {
	fields := reflect.VisibleFields(reflect.TypeOf(c))
	sort.Slice(fields, func(i, j int) bool {
		return fields[i].Name < fields[j].Name
	})
	values := reflect.ValueOf(c)

	w := tabwriter.NewWriter(b, minwidth, tabwidth, padding, padchar, flags)
	_, _ = fmt.Fprint(b, "The Defacto2 server configuration:\n\n")
	_, _ = fmt.Fprintf(w, "\t%s\t%s\t%s\n",
		h1, h3, h2)
	_, _ = fmt.Fprintf(w, "\t%s\t%s\t%s\n",
		strings.Repeat(line, len(h1)),
		strings.Repeat(line, len(h3)),
		strings.Repeat(line, len(h2)))

	for field := range slices.Values(fields) {
		if !field.IsExported() {
			continue
		}
		switch field.Name {
		case "GoogleAccounts":
			continue
		default:
		}
		val := values.FieldByName(field.Name)
		id := field.Name
		name := field.Tag.Get("env")
		if before, found := strings.CutSuffix(name, ",unset"); found {
			name = before
		}
		c.fprintField(w, id, name, val)
	}
	if err := w.Flush(); err != nil {
		_, _ = fmt.Fprintln(os.Stderr, err)
	}
	return b
}

// fprintField prints the id, name, value and help text to the tabwriter.
func (c Config) fprintField(w *tabwriter.Writer,
	id, name string,
	val reflect.Value,
) {
	_, _ = fmt.Fprintf(w, "\t\t\t\t\n")
	switch id {
	case "HTTPPort":
		_, _ = fmt.Fprintf(w, "\t%s\t%s\t%s\n", Format(id), name, valueHTTP(val))
	case "TLSPort":
		_, _ = fmt.Fprintf(w, "\t%s\t%s\t%s\n", Format(id), name, valueTLS(val))
	case "TLSCert", "TLSKey":
		_, _ = fmt.Fprintf(w, "\t%s\t%s\t%s\n", Format(id), name, valueCert(val, c.TLSPort.Value()))
	case Down, Prev, Thumb, Logger:
		fprintDirs(w, id, name, val.String())
	case "MaxProcs":
		_, _ = fmt.Fprintf(w, "\t%s\t%s\t%s\n", Format(id), name, valueProcs(val))
	case "GoogleIDs":
		_, _ = fmt.Fprintf(w, "\t%s\t%s\t%s\n", Format(id), name, valueGoogles(c.GoogleAccounts))
	default:
		fprintField2(w, id, name, val)
	}
}
