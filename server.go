// Package main is the entry point for the Defacto2 server application.
//
// Use the Task runner / build tool (https://taskfile.dev) to build or run the source code.
// $ task --list
//
// Repository: 	https://github.com/Defacto2/server
// Website:		https://defacto2.net
// License:
//
// Â© Defacto2, 2024
package main

import (
	"context"
	"embed"
	"errors"
	"fmt"
	"os"
	"runtime"
	"strconv"
	"strings"

	"github.com/Defacto2/server/cmd"
	"github.com/Defacto2/server/handler"
	"github.com/Defacto2/server/internal/command"
	"github.com/Defacto2/server/internal/config"
	"github.com/Defacto2/server/internal/logger"
	"github.com/Defacto2/server/internal/postgres"
	"github.com/Defacto2/server/internal/postgres/models"
	"github.com/Defacto2/server/model"
	"github.com/Defacto2/server/model/fix"
	"github.com/caarlos0/env/v10"
	_ "github.com/lib/pq"
	"github.com/volatiletech/sqlboiler/v4/queries/qm"
	"go.uber.org/zap"
)

//go:embed public/text/defacto2.txt
var brand []byte

//go:embed public/**/*
var public embed.FS

//go:embed view/**/*
var view embed.FS

// version is generated by the GoReleaser ldflags.
var version string

// LocalMode is used to always override the PRODUCTION_MODE and READ_ONLY environment variables.
// It removes the option to set a number environment variables when running the server locally.
// This is set using the -ldflags option when building the app.
//
// Example, go build -ldflags="-X 'main.LocalMode=true'", this will set the LocalMode variable to true.
var LocalMode string //nolint:gochecknoglobals

var (
	ErrCmd = errors.New("the command given did not work")
	ErrDB  = errors.New("could not initialize the database data")
	ErrEnv = errors.New("environment variable probably contains an invalid value")
	ErrFS  = errors.New("the directories repair broke")
	ErrLog = errors.New("the server cannot save any logs")
	ErrVer = errors.New("postgresql version request failed")
)

// main is the entry point for the application.
// By default the web server runs when no arguments are provided.
// Otherwise, the command-line arguments are parsed and the application exits.
func main() {
	dev := developmentLog()
	configs := environmentVars(dev)

	parseArguments(dev, configs)
	sanityChecks(dev, configs)
	repairs(dev, configs)

	prod := welcomeLog(configs)
	website := new(prod, configs)
	e := website.Controller()
	website.Info()
	if err := website.Start(e, configs); err != nil {
		prod.Fatalf("%s: please check the enviroment variables.", err)
	}

	w := os.Stdout
	go func() {
		localIPs, err := configs.Addresses()
		if err != nil {
			prod.Errorf("%s: %s", ErrEnv, err)
		}
		fmt.Fprintf(w, "%s\n", localIPs)
	}()

	if localMode() {
		go func() {
			fmt.Fprint(w, "Tap Ctrl + C, to exit at anytime.\n")
		}()
	}
	website.ShutdownHTTP(e)
}

// developmentLog is used to create a development logger before the environment variables are parsed.
func developmentLog() *zap.SugaredLogger {
	return logger.Development().Sugar()
}

// environmentVars is used to parse the environment variables and set the Go runtime.
func environmentVars(logr *zap.SugaredLogger) config.Config {
	configs := config.Config{}
	if err := env.Parse(&configs); err != nil {
		logr.Fatalf("%w: %s", ErrEnv, err)
	}
	configs.Override(localMode())

	if i := configs.MaxProcs; i > 0 {
		runtime.GOMAXPROCS(int(i))
	}
	return configs
}

// new is used to create the server controller instance.
func new(logr *zap.SugaredLogger, configs config.Config) handler.Configuration {
	c := handler.Configuration{
		Brand:   &brand,
		Import:  &configs,
		Logger:  logr,
		Public:  public,
		Version: version,
		View:    view,
	}
	if c.Version == "" {
		c.Version = cmd.Commit("")
	}
	c.RecordCount = RecordCount()
	return c
}

// parseArguments is used to parse the commandline arguments.
func parseArguments(logr *zap.SugaredLogger, c config.Config) {
	if logr == nil {
		return
	}
	code, err := cmd.Run(version, &c)
	if err != nil {
		logr.Errorf("%s: %s", ErrCmd, err)
		os.Exit(int(code))
	}
	useExitCode := code >= cmd.ExitOK
	if useExitCode {
		os.Exit(int(code))
	}
}

// sanityChecks is used to perform a number of sanity checks on the file assets and database.
// These are skipped if the FastStart environment variable is set.
func sanityChecks(logr *zap.SugaredLogger, configs config.Config) {
	if configs.FastStart || logr == nil {
		return
	}
	if err := configs.Checks(logr); err != nil {
		logr.Errorf("%s: %s", ErrEnv, err)
	}
	checks(logr, configs.ReadMode)
	conn, err := postgres.New()
	if err != nil {
		logr.Errorf("%s: %s", ErrDB, err)
		return
	}
	_ = conn.Check(logr, localMode())
}

// checks is used to confirm the required commands are available.
// These are skipped if readonly is true.
func checks(logr *zap.SugaredLogger, readonly bool) {
	if logr == nil || readonly {
		return
	}
	var buf strings.Builder
	for i, name := range command.Lookups() {
		if err := command.LookCmd(name); err != nil {
			buf.WriteString("\n\t\t\tmissing: " + name)
			buf.WriteString("\t" + command.Infos()[i])
		}
	}
	if buf.Len() > 0 {
		logr.Warnln("The following commands are required for the server to run in WRITE MODE",
			"\n\t\t\tThese need to be installed and accessible on the system path:"+
				"\t\t\t"+buf.String())
	}
	if err := command.LookupUnrar(); err != nil {
		if errors.Is(err, command.ErrVers) {
			logr.Warnf("Found unrar but " +
				"could not find unrar by Alexander Roshal, " +
				"is unrar-free mistakenly installed?")
			return
		}
		logr.Warnf("%s: %s", ErrCmd, err)
	}
}

// repairs is used to fix any known issues with the file assets and the database entries.
// These are skipped if the FastStart environment variable is set.
func repairs(logr *zap.SugaredLogger, configs config.Config) {
	if configs.FastStart || logr == nil {
		return
	}
	if err := configs.RepairFS(logr); err != nil {
		logr.Errorf("%s: %s", ErrFS, err)
	}
	if err := RepairDB(logr); err != nil {
		repairdb(logr, err)
	}
}

// welcomeLog is used to setup the logger for the server and print the startup message.
func welcomeLog(c config.Config) *zap.SugaredLogger {
	logr := logger.Development().Sugar()
	const welcome = "Welcome to the local Defacto2 web application."
	logr.Info(welcome)
	if localMode() {
		return logr
	}
	mode := "read-only mode"
	if !c.ReadMode {
		mode = "write mode"
	}
	switch c.ProductionMode {
	case true:
		if err := c.LogStorage(); err != nil {
			logr.Fatalf("%w: %s", ErrLog, err)
		}
		logr = logger.Production(c.LogDir).Sugar()
		s := "The server is running in a "
		s += strings.ToUpper("production, "+mode) + "."
		logr.Info(s)
	default:
		s := "The server is running in a "
		s += strings.ToUpper("development, "+mode) + "."
		logr.Warn(s)
	}
	return logr
}

// localMode is used to always override the PRODUCTION_MODE and READ_ONLY environment variables.
func localMode() bool {
	val, err := strconv.ParseBool(LocalMode)
	if err != nil {
		return false
	}
	return val
}

// RepairDB on startup checks the database connection and make any data corrections.
func RepairDB(logr *zap.SugaredLogger) error {
	if logr == nil {
		return fmt.Errorf("%w: %s", ErrLog, "no logger")
	}
	db, err := postgres.ConnectDB()
	if err != nil {
		return err
	}
	defer db.Close()
	var ver postgres.Version
	if err := ver.Query(); err != nil {
		return ErrVer
	}
	if localMode() {
		return nil
	}
	ctx := context.Background()
	return fix.All.Run(ctx, logr, db)
}

// repairdb is used to log the database repair error.
func repairdb(logr *zap.SugaredLogger, err error) {
	if logr == nil || err == nil {
		return
	}
	if errors.Is(err, ErrVer) {
		logr.Warnf("A %s, is the database server down?", ErrVer)
	} else {
		logr.Errorf("%s: %s", ErrDB, err)
	}
}

// RecordCount returns the number of records in the database.
func RecordCount() int {
	db, err := postgres.ConnectDB()
	if err != nil {
		return 0
	}
	defer db.Close()
	ctx := context.Background()
	fs, err := models.Files(qm.Where(model.ClauseNoSoftDel)).Count(ctx, db)
	if err != nil {
		return 0
	}
	return int(fs)
}
