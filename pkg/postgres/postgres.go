// Package postgres connects to and interacts with the PostgreSQL database server.
// The functions are specific to the Postgres platform rather than more generic or
// interchangeable SQL statements.
// The postgres/models directory is generated by SQLBoiler and should not be modified.
package postgres

import (
	"database/sql"
	"fmt"
	"net/url"
	"strconv"
	"strings"
)

const (
	// Name of the database driver.
	Name = "postgres"
	// Counter is a partial SQL statement to count the number of records.
	Counter = "COUNT(*) AS counter"
	// SumSize is a partial SQL statement to sum the filesize values of multiple records.
	SumSize = "SUM(filesize) AS size_sum"
)

// Connection details of the PostgreSQL database connection.
type Connection struct {
	Protocol string // Protocol scheme of the PostgreSQL database. Defaults to postgres.
	User     string // User is the database user used to connect to the database.
	Password string // Password is the password for the database user.
	HostName string // HostName is the host name of the server. Defaults to localhost.
	HostPort int    // HostPort is the port number the server is listening on. Defaults to 5432.
	Database string // Database is the database name.
	// NoSSLMode connects to the database using an insecure,
	// plain text connecction using the sslmode=disable param.
	NoSSLMode bool
}

// Open opens a PostgreSQL database connection.
func (c Connection) Open() (*sql.DB, error) {
	conn, err := sql.Open(Name, c.URL())
	if err != nil {
		return nil, err
	}
	return conn, nil
}

// URL returns a url used as a PostgreSQL database connection.
func (c Connection) URL() string {
	// "postgres://postgres:postgres@localhost:5432/postgres?sslmode=disable"
	if c.Protocol == "" {
		c.Protocol = Name
	}
	if c.HostName == "" {
		c.HostName = "localhost"
	}
	if c.HostPort < 1 {
		c.HostPort = 5432
	}
	var usr *url.Userinfo
	if c.User != "" && c.Password != "" {
		usr = url.UserPassword(c.User, c.Password)
	} else if c.User != "" {
		usr = url.User(c.User)
	}
	dns := url.URL{
		Scheme: c.Protocol,
		User:   usr,
		Host:   fmt.Sprintf("%s:%d", c.HostName, c.HostPort),
		Path:   c.Database,
	}
	if c.NoSSLMode {
		q := dns.Query()
		q.Set("sslmode", "disable")
		dns.RawQuery = q.Encode()
	}
	return dns.String()
}

// ConnectDB connects to the PostgreSQL database.
func ConnectDB() (*sql.DB, error) {
	dsn := Connection{
		User:      "root",
		Password:  "example",
		Database:  "defacto2-ps",
		NoSSLMode: true,
	}
	conn, err := sql.Open(Name, dsn.URL())
	if err != nil {
		return nil, err
	}
	return conn, nil
}

type Version string // Version of the PostgreSQL in use.

// Query the database version.
func (v *Version) Query() error {
	conn, err := ConnectDB()
	if err != nil {
		return err
	}
	rows, err := conn.Query("SELECT version();")
	if err != nil {
		return err
	}
	defer rows.Close()
	defer conn.Close()
	for rows.Next() {
		if err := rows.Scan(v); err != nil {
			return err
		}
	}
	return nil
}

func (v *Version) String() string {
	s := string(*v)
	const invalid = 2
	if x := strings.Split(s, " "); len(x) > invalid {
		_, err := strconv.ParseFloat(x[1], 32)
		if err != nil {
			return s
		}
		return fmt.Sprintf("using %s", strings.Join(x[0:2], " "))
	}
	return s
}

// SQLGroupStat is an SQL statement to select all the unique groups.
func SQLGroupStat() string {
	return "SELECT DISTINCT group_brand FROM files " +
		"CROSS JOIN LATERAL (values(group_brand_for),(group_brand_by)) AS T(group_brand) " +
		"WHERE NULLIF(group_brand, '') IS NOT NULL " + // handle empty and null values
		"GROUP BY group_brand"
}

// SQLGroupAll is an SQL statement to collect statistics for each of the unique groups.
func SQLGroupAll() string {
	return "SELECT DISTINCT group_brand, " +
		"COUNT(group_brand) AS count, " +
		"SUM(files.filesize) AS size_sum " +
		"FROM files " +
		"CROSS JOIN LATERAL (values(group_brand_for),(group_brand_by)) AS T(group_brand) " +
		"WHERE NULLIF(group_brand, '') IS NOT NULL " + // handle empty and null values
		"GROUP BY group_brand " +
		"ORDER BY group_brand ASC"
}

// SQLSumSection is an SQL statement to sum the filesizes of records matching the section.
func SQLSumSection() string {
	return "SELECT SUM(files.filesize) FROM files WHERE section = $1"
}

// SQLSumGroup is an SQL statement to sum the filesizes of records matching the group.
func SQLSumGroup() string {
	return "SELECT SUM(filesize) as size_sum FROM files WHERE group_brand_for = $1"
}

// SQLSumPlatform is an SQL statement to sum the filesizes of records matching the platform.
func SQLSumPlatform() string {
	return "SELECT sum(filesize) FROM files WHERE platform = $1"
}
